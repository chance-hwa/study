"""
일렬로 배열된 n개의 CpG 사이트(1~n)가 초기에 모두 메틸화(on, 1) 상태로 되어 있다고 가정합니다.

여러분은 이 CpG 사이트들의 메틸화 상태를 조절하여 가능한 메틸화 패턴의 개수를 구하고자 합니다.

여러분은 특정 효소를 사용해 다음과 같은 CpG 그룹의 메틸화 상태를 반대로 조절 할 수 있습니다. (0 ↔︎ 1)

효소 1: 모든 CpG 사이트의 메틸화 상태를 반대로 한다.

효소 2: 짝수번째의 CpG 사이트 (2, 4, 6, …)의 메틸화 상태를 반대로 한다.

효소 3: 홀수번째의 CpG 사이트 (1, 3, 5, …)의 메틸화 상태를 반대로 한다.

효소 4: 3*i + 1번째의 CpG 사이트 (1, 4, 7, 10, …)의 메틸화 상태를 반대로 한다.

여러분이 정확히 k번의 조절을 할 수 있을 때 (순서와 종류 자유) 나올 수 있는 메틸화 패턴의 개수를 구해보세요.

입력:

n (int): CpG 사이트의 개수 (1 ≤ n ≤ 1000)

k (int): 시도하는 조절 횟수 (0 ≤ k)

출력:

(int): k 번의 조작으로 얻을 수 있는 서로 다른 메틸화 패턴의 총 개수

Input: 
n = 1
k = 1

Output:
2

Explanation:
1번의 조작만으로는 어떤 효소를 통해 조절하더라도 [0], [1] 두 가지의 패턴만 가능


Input: 
n = 2
k = 1

Output:
3

Explanation:
[0, 0] by 효소 1
[1, 0] by 효소 2
[0, 1] by 효소 3


Input: 
n = 3
k = 1

Output:
4

Explanation:
[0, 0, 0] by 효소 1
[1, 0, 1] by 효소 2
[0, 1, 0] by 효소 3
[0, 1, 1] by 효소 4
"""

"""
설명

이 문제는 여러 개의 CpG 사이트(메틸화 상태 0/1)를 효소로 조작할 수 있는데, 효소 4종류가 각각 다른 규칙으로 CpG를 뒤집습니다.

전체 뒤집기

짝수 위치 뒤집기

홀수 위치 뒤집기

(3k+1) 위치 뒤집기

위 효소들의 조작을 시뮬레이션 하다보면 다음과 같은 사실을 알 수 있습니다.

각 효소는 같은 걸 두 번 쓰면 효과가 사라집니다. 즉, 한 효소를 몇 번 사용했는지는 중요하지 않고, 홀수 번 적용했는지만이 최종 상태에 영향을 줍니다.

또한 처음 세 종류의 효소는 서로 조합이 가능합니다.

예를 들어, 전체 뒤집기 + 짝수 뒤집기는 홀수 뒤집기와 같으므로, 이 세 효소의 조합은 원래 상태 또는 하나의 효소 효과로 단순화됩니다.

그리고 n이 3보다 크더라도, 처음 3개의 CpG 상태만으로 모든 패턴을 구분할 수 있습니다. 

왜냐하면 이 효소들의 작용 패턴은 인덱스의 짝/홀/3주기만을 기준으로 반복되기 때문입니다.

결국 문제는 “n ≤ 3”인 경우의 가능한 상태 개수를 계산하면, n > 3인 경우에도 그대로 적용할 수 있게 됩니다.

조작횟수가 작을 때는 짝수/홀수 제약 때문에 만들 수 없는 패턴이 있어서 경우의 수가 줄어듭니다.

구현:

시간 복잡도: O(1)

n과 k에 따라 조건문 한 번씩만 수행

공간 복잡도: O(1)

추가 저장 공간 없음
"""

def methylation_pattern_count(n: int, k: int) -> int:
    if k == 0:
        return 1
    if n == 1:
        return 2
    if n == 2:
        return 3 if k == 1 else 4
    # n >= 3
    if k == 1:
        return 4
    if k == 2:
        return 7
    return 8