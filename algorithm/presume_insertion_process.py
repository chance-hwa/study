"""
어떤 유전체 영역에서 여러 번 삽입된 DNA 조각들을 찾아냈습니다. 각 조각은 문자열 하나로 표현되며, 배열은 이러한 조각들이 나열된 상태를 나타냅니다. 

당신은 삽입된 DNA 조각을 제거함으로써 원래의 유전체 구조로부터 지금 구조가 어떻게 형성되었는지 추정하려고 합니다.

어떤 조각을 제거하면, 그 조각 양 옆으로 떨어져 있던 조각들은 원래 붙어있던 조각으로 간주할 수 있습니다.

동일한 DNA 조각이 연속으로 등장하는 구간은 하나의 삽입 이벤트로 간주할 수 있으며, 해당 구간을 한 번에 제거할 수 있습니다. 

하나의 클러스터는 실제로 한 번의 이벤트로 발생했을 확률이 높아 제거할 때 신뢰도가 높아집니다.

하나의 클러스터(k개의 연속된 동일 조각)를 제거할 때 얻는 신뢰도 점수는 k × k 입니다.

제거 순서를 자유롭게 할 수 있을 때, 최대 신뢰도 점수를 계산하세요.

입력:

fragments(List[str]): DNA 조각들의 나열된 상태. 하나의 조각은 문자열 하나로 표시되고, 각 조각은 중복될 수 있습니다.

출력:

(int): 각 조각을 제거해서 해석함으로써 얻을 수 있는 최대 신뢰도


예제 1:
Input: 
fragments = ["A"]

Output:
1

Explanation:
"A" 한 조각을 제거하고 신뢰도 점수는 1

예제 2:
Input: 
fragments = ["A", "A", "A"]

Output:
9

Explanation:
연속된 "A" 조각 3개를 제거하고 신뢰도 점수는 9

예제 3:
Input: 
fragments = ["A", "B", "B", "C", "C", "C", "C", "D", "B", "A"]

Output:
30 

Explanation:
1. 연속된 "C" 조각 4개를 한번에 제거하고 신뢰도 점수는 16 -> ["A", "B", "B", "D", "B", "A"]
2. "D" 조각 하나를 제거하고 신뢰도 점수는 1 -> ["A", "B", "B", "B", "A"]
3. 연속된 "B" 조각 3개를 제거하고 신뢰도 점수는 9 -> ["A", "A"]
4. 연속된 "A" 조각 2개를 제거하고 신뢰도 점수는 4
16 + 1 + 9 + 4 = 30

힌트 1
이 문제는 결국 어떤 조각을 언제 빼느냐가 중요한 문제입니다. 당연히 “지금”의 최선의 제거가 “미래”의 최선의 제거가 아닐 수 있습니다.

→ [“A”, “A”, “A”, “B”, “A”] 에서, A가 3개 연속됐다고 해서 지금 제거하는 건 손해일 수 있습니다.

힌트 2
전체 서열을 한 번에 처리하려고 하지 마세요.

→ 구간 단위로 생각해보세요.

구체적으로?
어떤 구간의 특정 조각을 기준으로 좌측과 우측을 분리한 뒤,
그 중간 조각들을 제거함으로써 같은 조각이 한 덩어리로 붙을 수 있는 상황을 만들 수 있는가를 탐색하는 것입니다.

힌트 3
조각을 리스트에서 제거하려고 하지 말자.

힌트 4
DP를 사용해서 풀 수 있다.

힌트 5
힌트 1에 이어서, “미래”를 보기 위한 방법이 무엇이 있을까요?

구체적으로
[“A”, ”A”, “A”, “B”, “C”, “A”] 를 기준으로 해봅시다.
힌트 2에서 얘기한 것과 같이 구간 단위로 나누어서 생각한다고 하면,
[“A”, “A”, “A”, “B”, “C”] 뒤에 “A”가 하나 있는 것을 알고 있는채로 구간을 분리했습니다.
[“A”, “A”, “A”, “B”, “C”]는 또 구간을 어떻게 나눠볼 수 있을까요?
"""

"""
예시 : [A, A, B, C, A, A, A, D]
3D dp
dp[l][r][k] = 구간 [l, r] 에서의 최대 점수
fragments[r]과 같은 조각이 오른쪽에 k개가 있을때

dp[0,7,0]을 출력 
dp[0,7,0] = dp[0,6,0] + 1
dp[0,6,0] = dp[0,3,0] + 9
dp[0,6,0] = dp[0,4,2]

dp[l, r-1, 0] + (k+1)^2

하고 왼쪽부터 봄
dp[l,i, k+1] + dp[i,r-1,0]
dp[0, 0, 3] + dp[1,3,0]
dp[0,1,3] + dp[2,3,0]
top down 으로 풀면 됨
재귀를 타고 들어간다
"""

"""
우리는 다음과 같이 세 개의 인자를 가지는 DP 테이블을 정의합니다

dp(l, r, k)

l부터 r까지의 구간을 고려하며

fragments[i]와 연속된 같은 조각이 k개 더 오른쪽에 붙어 있다고 가정했을 때의 최대 점수

즉, dp(l, r, k)는 다음과 같은 의미: 

fragments[l:r+1] 범위에서, fragments[r]과 같은 조각이 k개 추가로 붙어있는 상태에서 최대 점수.

왜 k를 넣는가?

["A", "B", "A"]처럼 A가 떨어져 있더라도, 중간의 B를 제거하고 나면 병합 가능

이 병합을 위해서는 병합될 조각 개수를 저장해야 하고, 이 정보를 k가 표현

점화식

Case1: 지금 연속된 조각을 바로 제거

dp(l, r, k) = dp(l, r-1, 0) + (k + 1)^2

단, fragments 리스트의 오른쪽에 fragments[r]과 같은 조각이 이미 여러 번 반복된다면 다른 조각이 나올때까지 r -= 1, k +=1을 진행한다.

Case2: 병합할 수 있는 다음 조각을 왼쪽에서 찾아 중간 조각은 제거하고 병합

if fragments[i] == fragments[r]: (l <= i < r)

dp(l, r, k) = max( dp(l, r, k), dp(l, i, k + 1) + dp(i + 1, r - 1, 0) )
"""
from functools import lru_cache

def max_confidence_dp(fragments):
    @lru_cache(maxsize=None)
    def dp(l, r, k):
        if l > r:
            return 0
        # 병합할 수 있는 동일 조각들을 미리 포함 (r 뒤쪽의 중복)
        while r > l and fragments[r] == fragments[r - 1]:
            r -= 1
            k += 1

        # (1) 지금 뒤의 조각들을 제거하는 경우
        res = dp(l, r - 1, 0) + (k + 1) ** 2

        # (2) 이전 동일 조각들과 병합하여 제거
        for i in range(l, r):
            if fragments[i] == fragments[r]:
                res = max(res, dp(l, i, k + 1) + dp(i + 1, r - 1, 0))

        return res

    return dp(0, len(fragments) - 1, 0)

"""
시간 복잡도: O(n^4)

i, j, k → O(n^3)

각 상태에서 내부 루프 O(n)

따라서 최악의 경우 O(n^4)

그러나 일반적으로 k는 모두 탐색하는 경우가 거의 없기 때문에 대부분 O(n^3)에 수렴할 것

공간 복잡도: O(n^3)

3D dp 복잡도 n^3

lru_cache에 의해 같은 dp(i, j, k)는 캐시됨
"""